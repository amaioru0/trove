import { Processor, WorkerOptions, GetNextJobOptions } from '../interfaces';
import { QueueBase } from './queue-base';
import { Repeat } from './repeat';
import { Job } from './job';
import { RedisConnection, RedisClient } from './redis-connection';
export declare interface Worker {
    on(event: 'active', listener: (job: Job, prev: string) => void): this;
    on(event: 'completed', listener: (job: Job) => void): this;
    on(event: 'drained', listener: () => void): this;
    on(event: 'error', listener: (failedReason: Error) => void): this;
    on(event: 'failed', listener: (job: Job, error: Error) => void): this;
    on(event: 'progress', listener: (job: Job, progress: number | object) => void): this;
    on(event: string, listener: Function): this;
}
/**
 *
 * This class represents a worker that is able to process jobs from the queue.
 * As soon as the class is instantiated it will start processing jobs.
 *
 */
export declare class Worker<DataType = any, ResultType = any, NameType extends string = string> extends QueueBase {
    opts: WorkerOptions;
    private drained;
    private waiting;
    private running;
    private processFn;
    private resumeWorker;
    private paused;
    private _repeat;
    private childPool;
    private timerManager;
    private blockingConnection;
    private processing;
    constructor(name: string, processor?: string | Processor<DataType, ResultType, NameType>, opts?: WorkerOptions, Connection?: typeof RedisConnection);
    /**
     *
     * Waits until the worker is ready to start processing jobs.
     * In general only useful when writing tests.
     *
     */
    waitUntilReady(): Promise<RedisClient>;
    get repeat(): Promise<Repeat>;
    run(): Promise<any[]>;
    /**
     * Returns a promise that resolves to the next job in queue.
     * @param token - worker token to be assigned to retrieved job
     * @returns a Job or undefined if no job was available in the queue.
     */
    getNextJob(token: string, { block }?: GetNextJobOptions): Promise<Job<any, any, string>>;
    private moveToActive;
    private waitForJob;
    /**
     *
     * This function is exposed only for testing purposes.
     */
    delay(): Promise<void>;
    private nextJobFromJobData;
    processJob(job: Job<DataType, ResultType, NameType>, token: string): Promise<void | Job<any, any, string>>;
    /**
     *
     * Pauses the processing of this queue only for this worker.
     */
    pause(doNotWaitActive?: boolean): Promise<void>;
    /**
     *
     * Resumes processing of this worker (if paused).
     */
    resume(): void;
    /**
     *
     * Checks if worker is paused.
     *
     * @returns true if worker is paused, false otherwise.
     */
    isPaused(): boolean;
    /**
     *
     * Checks if worker is currently running.
     *
     * @returns true if worker is running, false otherwise.
     */
    isRunning(): boolean;
    /**
     *
     * Closes the worker and related redis connections.
     *
     * This method waits for current jobs to finalize before returning.
     *
     * @param force - Use force boolean parameter if you do not want to wait for
     * current jobs to be processed.
     *
     * @returns Promise that resolves when the worker has been closed.
     */
    close(force?: boolean): Promise<void>;
    /**
     * Returns a promise that resolves when active jobs are cleared
     *
     * @returns
     */
    private whenCurrentJobsFinished;
    private retryIfFailed;
}
